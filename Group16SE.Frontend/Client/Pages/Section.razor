@using Group16SE.Frontend.Shared
@using MudBlazor

@inject IDialogService Dialog

<MudGrid Spacing="4">
    <MudItem xs="8">
        <MudAutocomplete T="CommentModel"
                         ResetValueOnEmptyText="true"
                         Dense="true"
                         @ref="autocomplete"
                         @bind-Text="@CommentInputText"
                         @bind-Placeholder="@SavedInputText"
                         OnKeyUp="KeyPressed"
                         @onfocus="() => CommentInputText = SavedInputText"
                         SearchFunc="SortCommentsFunc"
                         ToStringFunc="@(e => e.Content)"
                         Immediate="true">
            <ItemTemplate Context="e">
                @if (!string.IsNullOrWhiteSpace(e.Content))
                {
                    <MudGrid>

                        <MudItem xs="10"
                                 md="11">
                            <div @onclick="async () => await CommentFromBank(BankComments.Where(comment => comment.Content == e.Content).ElementAt(0))">
                                <MudHighlighter Class="pa-1 mud-elevation-2 mud-theme-primary"
                                                UntilNextBoundary="true"
                                                Style="background-color:transparent; font-weight:bold; padding:initial"
                                                Text="@e.Content"
                                                HighlightedText="@CommentInputText">
                                </MudHighlighter>
                            </div>
                        </MudItem>

                        <MudItem xs="2" md="1">
                            <MudIconButton Icon="@Icons.Material.DeleteForever"
                                           @onclick="async () => await DeleteBankComment(e)"
                                           Size="Size.Small">
                            </MudIconButton>
                        </MudItem>
                    </MudGrid>
                }
                else
                {
                    <MudGrid>
                        <MudItem xs="10"
                                 md="11">
                            <div @onclick="async () => await CommentFromInput()">
                                <MudHighlighter Class="pa-1 mud-elevation-2 mud-theme-primary"
                                                UntilNextBoundary="true"
                                                Style="background-color:transparent; font-weight:bold; padding:initial"
                                                @bind-Text="@CommentInputText"
                                                HighlightedText="@CommentInputText">
                                </MudHighlighter>
                            </div>
                        </MudItem>

                        <MudItem xs="2" md="1">
                            <MudIconButton Icon="@Icons.Material.Clear"
                                           @onclick="ClearAutocomplete"
                                           Size="Size.Small">
                            </MudIconButton>
                        </MudItem>
                    </MudGrid>
                }
            </ItemTemplate>
        </MudAutocomplete>
        @for (int i = 0; i < SectionModel.Comments.Count; i++)
        {
            int local = i;

            CommentModel temp = SectionModel.Comments.ElementAt(i);
            <MudItem xs="12">
                <Comment @bind-CommentModel="temp"
                         OnCommentDeleted="DeleteComment"
                         OnCommentEdited="UpdateComment">
                </Comment>
            </MudItem>
        }
    </MudItem>
    <MudItem xs="4">
        <MudGrid Spacing="1">
            @for (int i = 0; i < SectionModel.SliderPoints.Count; i++)
            {
                int local = i;
                <MudItem xs="12">
                    @{
                        SliderPointModel sliderPointModel = SectionModel.SliderPoints[local];
                        <MudSlider @bind-Value="sliderPointModel.Value" Step="sliderPointModel.Step" Min="sliderPointModel.Min" Max="sliderPointModel.Max">@sliderPointModel.Tag: @sliderPointModel.Value</MudSlider>
                    }
                </MudItem>
            }
            @for (int i = 0; i < SectionModel.SwitchPoints.Count; i++)
            {
                int local = i;
                <MudItem xs="12">
                    @{
                        SwitchPointModel switchPointModel = SectionModel.SwitchPoints[local];
                        <MudSwitch @bind-Checked="switchPointModel.Value" Color="Color.Primary" Label="@switchPointModel.Tag"></MudSwitch>
                    }
                </MudItem>
            }
            @for (int i = 0; i < SectionModel.AutocompletePoints.Count; i++)
            {
                int local = i;
                <MudItem xs="12">
                    @{
                        AutocompletePointModel autocompletePointModel = SectionModel.AutocompletePoints[local];
                        <MudAutocomplete @bind-Value="autocompletePointModel.Value"></MudAutocomplete>
                    }
                </MudItem>
            }
            <MudItem xs="12">
                @{
                    string suggestedMarkText = "Suggested mark: " + suggestedMark;
                    string maximumMarkText = "/" + maximumMark;
                }
                <MudTextField T="int"  @bind-Value="SectionModel.GivenMark" HelperText="@suggestedMarkText" Variant="Variant.Outlined" Adornment="Adornment.End" AdornmentText="@maximumMarkText" />
            </MudItem>
        </MudGrid>
    </MudItem>
</MudGrid>

@code {
    /// <summary>
    /// Contains data relating to a single section within an attempt.
    /// </summary>
    [Parameter]
    public SectionModel SectionModel { get; set; }
    /// <summary>
    /// Contains all the comments in a comment bank for a section.
    /// </summary>
    [Parameter]
    public List<CommentModel> BankComments { get; set; }

    /// <summary>
    /// Callback for when section data is modified..
    /// </summary>
    [Parameter]
    public EventCallback<SectionModel> SectionModelChanged { get; set; }
    /// <summary>
    /// Callback for when bank data is modified.
    /// </summary>
    [Parameter]
    public EventCallback<List<CommentModel>> BankCommentsChanged { get; set; }

    private List<CommentModel> searchComments;

    private int suggestedMark = 6;
    private int maximumMark = 10;

    private string inputText;
    private string savedText;

    /// <summary>
    /// Stores the most recent non-blank user input.
    /// </summary>
    public string SavedInputText
    {
        get
        {
            return (savedText);
        }
        set
        {
            if (value == "(*_*)")
            {
                savedText = "";
            }
            else if (!string.IsNullOrWhiteSpace(value))
            {
                savedText = value;
            }
        }
    }

    /// <summary>
    /// Stores the user input.
    /// </summary>
    public string CommentInputText
    {
        get
        {
            return inputText;
        }
        set
        {
            inputText = value;

            if (string.IsNullOrWhiteSpace(value))
            {
                SavedInputText = inputText;
            }
        }
    }

    /// <summary>
    /// Reference to the autocomplete component.
    /// </summary>
    private MudAutocomplete<CommentModel> autocomplete;

    /// <summary>
    /// Triggers the callback to update bank comments in the parent component.
    /// </summary>
    /// <param name="comments">The updated comments.</param>
    /// <returns></returns>
    public async Task OnBankCommentsChanged(List<CommentModel> comments)
    {
        await BankCommentsChanged.InvokeAsync(comments);
    }

    /// <summary>
    /// Triggers the callback to update section comments in the parent component.
    /// </summary>
    /// <param name="comments">The updated comments.</param>
    private async Task SectionCommentsChanged(List<CommentModel> comments)
    {
        SectionModel.Comments = comments;
        await SectionModelChanged.InvokeAsync(SectionModel);
    }

    /// <summary>
    /// Sorts the bank for the autocomplete component.
    /// </summary>
    /// <param name="sortString">The string to search for.</param>
    /// <returns>Array of CommentModels that contain the sortString.</returns>
    private async Task<IEnumerable<CommentModel>> SortCommentsFunc(string sortString)
    {
        // As this effectively runs OnChange, the saved text is updated here.
        SavedInputText = sortString;

        // Creates a copy of BankComments but the objects within are references (intended).
        searchComments = new List<CommentModel>(BankComments);
        // Blank comment to go at the start so the user can select whatever they are currently inputting.
        searchComments.Insert(0, new CommentModel());

        if (string.IsNullOrEmpty(sortString))
        {
            return (searchComments.ToArray());
        }
        return searchComments.ToArray().Where(comment => comment.Content.Contains(sortString, StringComparison.InvariantCultureIgnoreCase) || string.IsNullOrWhiteSpace(comment.Content));
    }

    /// <summary>
    /// Creates a new comment if the enter key is pressed.
    /// </summary>
    /// <param name="e">The events that just occured.</param>
    /// <returns></returns>
    private async Task KeyPressed(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await CommentFromInput();
        }
        else if (e.Key == "Backspace")
        {
            // Prevents there being permanently one character left in the input box.
            // The saved input text preserves the user input but prevents null & whitespace.
            if (SavedInputText.Length == 1)
            {
                SavedInputText = "(*_*)";
            }
        }
    }

    /// <summary>
    /// Clears the contents of the autocomplete and the saved text.
    /// </summary>
    private void ClearAutocomplete()
    {
        CommentInputText = "";
        SavedInputText = "(*_*)";
        // This seems to force update the autocomplete.
        autocomplete.ToggleMenu();
    }

    /// <summary>
    /// Deletes a single comment from the section.
    /// </summary>
    /// <param name="comment">Comment to be deleted.</param>
    /// <returns></returns>
    private async Task DeleteComment(CommentModel comment)
    {
        SectionModel.DeleteCommentInstance(comment);
        if (comment.OriginalCommentModel.Uses <= 0)
        {
            BankComments.Remove(comment.OriginalCommentModel);
        }
        await SectionModelChanged.InvokeAsync(SectionModel);
        await BankCommentsChanged.InvokeAsync(BankComments);
    }

    /// <summary>
    /// Deletes a single comment from the bank.
    /// </summary>
    /// <param name="comment">Comment to be deleted.</param>
    /// <returns></returns>
    private async Task DeleteBankComment(CommentModel comment)
    {
        autocomplete.ToggleMenu();

        // Displays warning dialog.
        IDialogReference dialog = Dialog.Show<DeleteBankCommentDialog>("Delete comment");
        DialogResult result = await dialog.Result;

        // If the user submits.
        if (!result.Cancelled)
        {
            BankComments.Remove(comment);
            await BankCommentsChanged.InvokeAsync(BankComments);
        }
    }

    /// <summary>
    /// Updates a comment when it is edited.
    /// </summary>
    /// <param name="comment">The comment to be updated.</param>
    /// <returns></returns>
    private async Task UpdateComment(CommentModel comment)
    {
        if(comment.EditMode == EditMode.Bank)
        {
            comment.EditCommentGlobal();
        }
        else if(comment.EditMode == EditMode.Instance)
        {
            comment.EditCommentInstance(BankComments);
        }
        comment.EditMode = EditMode.None;
        // If it is not being used anywhere (across attempts).
        if(comment.OriginalCommentModel.Uses <= 0)
        {
            // Remove comment from the bank.
            BankComments.Remove(comment.OriginalCommentModel);
        }
        await BankCommentsChanged.InvokeAsync(BankComments);
        await SectionModelChanged.InvokeAsync(SectionModel);
    }

    /// <summary>
    /// Creates a comment from another comment (a bank comment).
    /// </summary>
    /// <param name="comment">The comment to create another comment from.</param>
    /// <returns></returns>
    private async Task CommentFromBank(CommentModel comment)
    {
        SectionModel.NewCommentFromComment(comment);
        await SectionModelChanged.InvokeAsync(SectionModel);
        await BankCommentsChanged.InvokeAsync(BankComments);
        ClearAutocomplete();
    }

    /// <summary>
    /// Creates a comment from the text in the input.
    /// </summary>
    /// <returns></returns>
    private async Task CommentFromInput()
    {
        SavedInputText = CommentInputText;

        // This is to prevent the user from entering the exact same comment twice and
        // both being put in the bank. Also prevents an identical comment being added 
        // when selecting a comment with the arrow keys and pressing enter.
        CommentModel bankComment = null;
        foreach (CommentModel comment in BankComments)
        {
            if (comment.Content == SavedInputText)
            {
                bankComment = comment;
                ClearAutocomplete();
            }
        }

        if (!string.IsNullOrWhiteSpace(SavedInputText))
        {
            if (bankComment == null)
            {
                // If an identical comment is found in the bank, the new comment is created 
                // from that instead.
                SectionModel.NewCommentFromString(BankComments, SavedInputText);
            }
            else
            {
                SectionModel.NewCommentFromComment(bankComment);
            }
            await SectionModelChanged.InvokeAsync(SectionModel);
            await BankCommentsChanged.InvokeAsync(BankComments);
            ClearAutocomplete();

        }
    }
}